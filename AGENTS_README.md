# Interactive Agents - User Guide

## LLM Integration (Optional)

**By default, the implementation uses rule-based reasoning** (no LLM). However, you can now **optionally enable Google Gemini API** for AI-powered reasoning!

### Without API Key (Default)
- ‚úÖ No API keys needed
- ‚úÖ Works completely offline
- ‚úÖ Fast and free
- ‚ùå Limited to predefined patterns
- ‚ùå Cannot handle novel reasoning

### With Google Gemini API Key
- ‚úÖ Real AI-powered reasoning
- ‚úÖ Can handle complex, novel tasks
- ‚úÖ Better tool selection and parameter extraction
- ‚úÖ Smarter retry strategies
- ‚ùå Requires API key
- ‚ùå Requires internet connection
- ‚ùå May incur API costs (Gemini has free tier)

## Overview

The Interactive Agents page allows you to create and interact with agents that can execute multi-step tasks. The system provides real-time visualizations of agent memory (conversation history and working memory) and retry loops.

## Features

- **Agent Creation**: Create ReAct or Simple agents with customizable tools
- **Multi-Step Task Execution**: Agents can break down complex tasks into sequential steps
- **Memory Visualization**: View conversation history and working memory in real-time
- **Retry Loop Visualization**: See how agents handle errors and retry failed operations
- **Multiple Tools**: Calculator, Web Search (mock), and Code Executor
- **Real-Time Console**: Watch agent execution step-by-step

## No API Keys Required - Rule-Based Implementation

**Important**: The current implementation is fully client-side and does **not** require any API keys. **It does NOT use any LLM (Large Language Model) API.**

### How It Actually Works

The agent's "reasoning" is **rule-based**, not LLM-generated. It uses simple pattern matching and keyword detection:

- **Reasoning**: If/else statements checking for keywords like "calculate", "search", "code"
- **Tool Selection**: Pattern matching on task text to choose appropriate tools
- **No AI Generation**: All text is template-based, not generated by a language model

This means:
- ‚úÖ No API costs
- ‚úÖ Works offline
- ‚úÖ Fast execution
- ‚ùå Limited to predefined patterns
- ‚ùå Cannot handle novel or complex reasoning

The tools available are:
- **Calculator**: Pure JavaScript arithmetic operations
- **Web Search**: Mock implementation (returns simulated results)
- **Code Executor**: Sandboxed JavaScript execution (limited for security)

## How to Use

### 1. Access the Agents Page

Navigate to `agents.html` from the main page, or go directly to `/agents.html`.

### 2. Create an Agent

1. **Enter Agent Name**: Give your agent a name (e.g., "My Agent")
2. **Select Agent Type**:
   - **ReAct Agent**: Uses Reasoning and Acting pattern for complex multi-step tasks
   - **Simple Agent**: Basic agent for straightforward calculations
3. **Choose Tools**: Select which tools your agent can use:
   - ‚òëÔ∏è Calculator (recommended for math tasks)
   - ‚òê Web Search (mock results)
   - ‚òê Code Executor (sandboxed JavaScript)
4. **Optional: Enter Google Gemini API Key**:
   - Leave empty for rule-based reasoning (works offline)
   - Enter your API key for AI-powered reasoning
   - Get your key at: https://makersuite.google.com/app/apikey
   - **Security Note**: API keys are stored in browser memory only (not saved)
5. Click **"Create Agent"**

### 3. Enter a Task

Type a multi-step task in the task input field. Examples:

**Simple calculation:**
```
Calculate 15 * 23
```

**Multi-step task:**
```
Calculate 15 * 23, then add 100 to the result, and finally divide by 5
```

**Complex task:**
```
Find the square root of 144, then multiply by 10, and add 50
```

### 4. Execute the Task

1. Click **"Execute Task"** (enabled after creating an agent)
2. Watch the execution in real-time:
   - **Execution Console**: See each step (reasoning, action, observation, retries)
   - **Memory Visualization**: View conversation history and working memory updates
   - **Retry Loop Visualization**: See retry attempts if any errors occur
   - **Statistics**: Track steps executed, retries, success rate, and memory size

### 5. Control Execution

- **Speed Slider**: Adjust execution speed (0.1x to 5x)
- **Stop Button**: Pause execution at any time
- **Reset Button**: Clear everything and start fresh

## Understanding the Visualizations

### Memory Visualization

- **Conversation History**: Chronological list of all user-agent interactions
- **Working Memory**:
  - **Facts**: Key-value pairs stored during execution
  - **Context**: Variables and state information
  - **Intermediate Results**: Results from each step

### Retry Loop Visualization

Shows:
- Each retry attempt with status (‚úÖ Success, ‚ùå Failed, ‚è≥ Pending)
- Retry strategy used (simple retry, alternative tool, refined approach)
- Error messages and recovery attempts
- Timeline of retry attempts

### Execution Console

Real-time log showing:
- üß† **Reasoning**: Agent's thought process
- ‚ö° **Action**: Tool execution
- üëÅÔ∏è **Observation**: Results and observations
- üîÑ **Retry**: Retry attempts with strategies

## Example Tasks

### Example 1: Simple Calculation
```
Task: Calculate 25 * 4 + 10
```
The agent will use the calculator tool to compute the result.

### Example 2: Multi-Step Task
```
Task: Calculate 100 / 5, then multiply by 3, and finally subtract 20
```
The agent will:
1. Execute: 100 / 5 = 20
2. Use result (20) in next step: 20 * 3 = 60
3. Use result (60) in final step: 60 - 20 = 40

### Example 3: Task with Context
```
Task: Calculate 50 * 2, then add the result to 100
```
The agent automatically passes the result from step 1 to step 2.

## Agent Types

### ReAct Agent

- **Best for**: Complex multi-step tasks
- **Features**:
  - Reasoning before each action
  - Automatic retry with multiple strategies
  - Context-aware task execution
  - Better error handling

### Simple Agent

- **Best for**: Single-step calculations
- **Features**:
  - Direct execution
  - Faster for simple tasks
  - Minimal overhead

## Retry Strategies

When an action fails, the ReAct agent tries different strategies:

1. **Simple Retry**: Retry the same action
2. **Refined Approach**: Modify parameters and retry
3. **Alternative Tool**: Try a different tool
4. **Fallback**: Use a simpler method

## Tips

1. **Be Specific**: Clear, step-by-step instructions work best
2. **Use Natural Language**: Write tasks as you would explain them
3. **Multi-Step Tasks**: Use connectors like "then", "and", "finally"
4. **Context Passing**: Refer to "the result" or "it" to use previous step results
5. **Watch the Console**: The execution console shows detailed reasoning

## Limitations

### Without API Key (Rule-Based Mode)
- **No Real LLM**: Agents use **rule-based keyword matching**, not large language models
- **No AI Generation**: All agent responses are pre-written templates
- **Limited Reasoning**: Can only handle tasks that match predefined patterns

### With API Key (LLM Mode)
- **API Dependency**: Requires internet connection and valid API key
- **API Costs**: May incur costs (though Gemini has generous free tier)
- **Rate Limits**: Subject to API rate limits
- **Security**: API key is stored in browser memory (consider backend proxy for production)

### General Limitations
- **Mock Web Search**: Web search returns simulated results
- **Limited Code Execution**: Code executor is heavily sandboxed for security
- **Client-Side Only**: All processing happens in the browser

## Google Gemini API Integration

**Current Status**: The system now supports **optional Google Gemini API integration**!

### How It Works

When you provide a Google Gemini API key:
1. **Reasoning**: The agent uses Gemini to analyze tasks and determine actions
2. **Tool Selection**: Gemini suggests which tool to use based on the task
3. **Parameter Extraction**: Gemini extracts and formats tool parameters
4. **Retry Strategies**: Gemini suggests retry strategies when actions fail

When no API key is provided:
- Falls back to rule-based reasoning (works offline)

### Getting a Gemini API Key

1. Visit: https://makersuite.google.com/app/apikey
2. Sign in with your Google account
3. Click "Create API Key"
4. Copy the API key
5. Paste it into the "Google Gemini API Key" field when creating an agent

### API Costs

- **Free Tier**: Gemini Pro has a generous free tier
- **Pricing**: Check current pricing at https://ai.google.dev/pricing
- **Rate Limits**: Subject to API rate limits

### Security Considerations

‚ö†Ô∏è **Important**: API keys are stored in browser memory only (not saved to disk or sent to any server except Google's API). For production use:

- Consider using a backend proxy to hide API keys
- Never commit API keys to version control
- Use environment variables or secure storage
- Implement rate limiting

## Adding Other LLM APIs

To add support for other LLM providers (OpenAI, Anthropic, etc.):

### Option 1: Replace Reasoning with LLM API

Modify the `reason()` method in `ReActAgent` to call a real LLM:

```typescript
// src/agents/agents/react-agent.ts
private async reason(task: string, previousSteps: AgentStep[]): Promise<AgentStep> {
  // Instead of rule-based reasoning, call LLM API
  const prompt = `You are an AI agent. Analyze this task: "${task}"\n
    Previous steps: ${JSON.stringify(previousSteps)}\n
    What tool should you use and why?`;
  
  const llmResponse = await this.callLLMAPI(prompt);
  
  return {
    stepId: `step-${Date.now()}`,
    timestamp: Date.now(),
    type: 'reasoning',
    content: llmResponse.reasoning
  };
}

private async callLLMAPI(prompt: string): Promise<any> {
  // Example with OpenAI
  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${this.apiKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      model: 'gpt-4',
      messages: [{ role: 'user', content: prompt }]
    })
  });
  return await response.json();
}
```

### Option 2: Add LLM as a Tool

Create an LLM tool that the agent can use:

```typescript
// src/agents/tools/llm-tool.ts
export class LLMTool implements Tool {
  name = 'llm';
  description = 'Uses AI to generate responses and reasoning';
  
  async execute(params: { prompt: string }): Promise<ToolResult> {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: 'gpt-4',
        messages: [{ role: 'user', content: params.prompt }]
      })
    });
    
    const data = await response.json();
    return {
      success: true,
      result: data.choices[0].message.content
    };
  }
}
```

### Required Changes

1. **Add API Key Input to UI** (`src/agents/ui/agent-creator.ts`):
   ```typescript
   // Add API key field
   <input type="password" id="api-key" placeholder="Enter API key (optional)">
   ```

2. **Store API Key Securely**:
   - Never commit API keys to git
   - Use environment variables or secure storage
   - Consider using a backend proxy to hide keys

3. **Update Agent Constructor**:
   ```typescript
   constructor(name: string, availableTools: string[], apiKey?: string) {
     this.apiKey = apiKey;
     // ...
   }
   ```

### Supported LLM Providers

- **OpenAI** (GPT-4, GPT-3.5)
- **Anthropic** (Claude)
- **Google** (Gemini)
- **Open Source** (via Ollama, LM Studio, etc.)

### Security Warning

‚ö†Ô∏è **Never expose API keys in client-side code!** If you add LLM integration:
- Use a backend proxy to hide API keys
- Or use serverless functions (Vercel, Netlify)
- Never commit `.env` files with API keys

### Security Considerations

- **Never commit API keys** to version control
- Use environment variables or secure storage
- Consider rate limiting for API calls
- Validate and sanitize all inputs

## Troubleshooting

### Agent Not Creating
- Ensure at least one tool is selected
- Check browser console for errors

### Task Not Executing
- Verify agent is created first
- Check that task text is not empty
- Look at console for error messages

### Memory Not Updating
- Memory updates after each successful step
- Check that steps are completing successfully
- Verify browser console for errors

### Retry Loops Not Showing
- Retries only appear when actions fail
- Check execution console for error messages
- Verify agent type is ReAct (Simple agent has limited retry)

## Technical Details

### Architecture

- **Frontend**: TypeScript, HTML, CSS
- **No Backend**: Fully client-side implementation
- **Visualization**: Plotly.js for charts
- **Styling**: Glassmorphism theme matching main site

### File Structure

```
src/agents/
‚îú‚îÄ‚îÄ agents/          # Agent implementations
‚îú‚îÄ‚îÄ tools/           # Tool implementations
‚îú‚îÄ‚îÄ memory/          # Memory management
‚îú‚îÄ‚îÄ ui/              # UI components
‚îú‚îÄ‚îÄ visualizations/  # Visualization components
‚îî‚îÄ‚îÄ simulator.ts     # Main controller
```

## Future Enhancements

Potential improvements:
- Real LLM API integration (OpenAI, Anthropic, etc.)
- Real web search API integration
- More sophisticated reasoning
- Agent-to-agent communication
- Persistent memory across sessions
- Export/import agent configurations

---

**Last Updated**: December 2025

